/**
 * ÁõëÊéßÊ®°ÂºèÊéßÂà∂Âô®
 * ÂçèË∞ÉÊñá‰ª∂ÁõëÊéß„ÄÅÂèòÂåñÊ£ÄÊµãÂíåÊµãËØïËøêË°å
 */

const EventEmitter = require('events');
const FileWatcher = require('./file-watcher');
const ChangeDetector = require('./change-detector');

class WatchMode extends EventEmitter {
    constructor(testRunner, options = {}) {
        super();

        this.testRunner = testRunner;
        this.options = {
            // ÁõëÊéßÈÄâÈ°π
            debounce: 200,
            clearConsole: true,
            runOnStart: true,
            failFast: false,
            verbose: false,
            // ÈÄöÁü•ÈÄâÈ°π
            showNotifications: true,
            notifyOnSuccess: false,
            notifyOnFailure: true,
            // ÊÄßËÉΩÈÄâÈ°π
            enableParallel: true,
            maxWorkers: require('os').cpus().length,
            ...options
        };

        this.fileWatcher = new FileWatcher({
            debounce: this.options.debounce,
            ...this.options.watcherOptions
        });

        this.changeDetector = new ChangeDetector({
            smartDetection: true,
            enableHashing: true,
            ...this.options.detectorOptions
        });

        this.isRunning = false;
        this.lastRunTime = null;
        this.runCount = 0;
        this.stats = {
            totalRuns: 0,
            successfulRuns: 0,
            failedRuns: 0,
            averageRunTime: 0,
            filesChanged: 0,
            lastRunDuration: 0
        };

        this.setupEventHandlers();
    }

    /**
     * ËÆæÁΩÆ‰∫ã‰ª∂Â§ÑÁêÜÂô®
     */
    setupEventHandlers() {
        // Êñá‰ª∂ÂèòÂåñ‰∫ã‰ª∂
        this.fileWatcher.on('change', async (changeInfo) => {
            await this.handleFileChange(changeInfo);
        });

        // Êñá‰ª∂ÁõëÊéßÂêØÂä®‰∫ã‰ª∂
        this.fileWatcher.on('started', (info) => {
            this.emit('watchStarted', info);
        });

        // Êñá‰ª∂ÁõëÊéßÂÅúÊ≠¢‰∫ã‰ª∂
        this.fileWatcher.on('stopped', () => {
            this.emit('watchStopped');
        });

        // Â§ÑÁêÜËøõÁ®ã‰ø°Âè∑
        process.on('SIGINT', () => {
            this.gracefulShutdown();
        });

        process.on('SIGTERM', () => {
            this.gracefulShutdown();
        });
    }

    /**
     * ÂêØÂä®ÁõëÊéßÊ®°Âºè
     */
    async start() {
        if (this.isRunning) {
            console.log('‚ö†Ô∏è Watch mode is already running');
            return;
        }

        console.log('üöÄ Starting MiniTest in watch mode...');
        this.isRunning = true;

        try {
            // Ê∏ÖÂ±èÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
            if (this.options.clearConsole) {
                this.clearConsole();
            }

            // ÊòæÁ§∫ÂêØÂä®‰ø°ÊÅØ
            this.showWelcome();

            // ÂàùÂßãËøêË°åÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
            if (this.options.runOnStart) {
                await this.runInitialTests();
            }

            // ÂêØÂä®Êñá‰ª∂ÁõëÊéß
            await this.fileWatcher.start();

            // ÊòæÁ§∫ÁõëÊéßÁä∂ÊÄÅ
            this.showWatchStatus();

            this.emit('started');

        } catch (error) {
            console.error('‚ùå Failed to start watch mode:', error.message);
            this.isRunning = false;
            throw error;
        }
    }

    /**
     * ÂÅúÊ≠¢ÁõëÊéßÊ®°Âºè
     */
    async stop() {
        if (!this.isRunning) {
            return;
        }

        console.log('üõë Stopping watch mode...');
        this.isRunning = false;

        try {
            // ÂÅúÊ≠¢Êñá‰ª∂ÁõëÊéß
            await this.fileWatcher.stop();

            // ‰øùÂ≠òÂèòÂåñÊ£ÄÊµãÁºìÂ≠ò
            this.changeDetector.saveCache();

            // ÊòæÁ§∫ÊúÄÁªàÁªüËÆ°
            this.showFinalStats();

            this.emit('stopped');

        } catch (error) {
            console.error('‚ùå Error stopping watch mode:', error.message);
        }
    }

    /**
     * ‰ºòÈõÖÂÖ≥Èó≠
     */
    async gracefulShutdown() {
        console.log('\nüîÑ Gracefully shutting down...');
        await this.stop();
        process.exit(0);
    }

    /**
     * Â§ÑÁêÜÊñá‰ª∂ÂèòÂåñ
     */
    async handleFileChange(changeInfo) {
        if (!this.isRunning) {
            return;
        }

        this.stats.filesChanged++;

        try {
            // ÂàÜÊûêÂèòÂåñÂΩ±Âìç
            const analysis = await this.changeDetector.analyzeChange(changeInfo);

            if (!analysis.hasContentChanged && analysis.affectedTests.length === 0) {
                // Êñá‰ª∂ÂÜÖÂÆπÊú™ÂèòÂåñÔºåË∑≥ËøáÊµãËØï
                if (this.options.verbose) {
                    console.log('‚è≠Ô∏è Skipping tests - no content changes detected');
                }
                return;
            }

            // Ê∏ÖÂ±èÂáÜÂ§áÊñ∞ÁöÑËøêË°å
            if (this.options.clearConsole) {
                this.clearConsole();
            }

            // ÊòæÁ§∫ÂèòÂåñ‰ø°ÊÅØ
            this.showChangeInfo(changeInfo, analysis);

            // ËøêË°åÊµãËØï
            await this.runTests(analysis);

        } catch (error) {
            console.error('‚ùå Error handling file change:', error.message);
            this.emit('error', error);
        }
    }

    /**
     * ÂàùÂßãÊµãËØïËøêË°å
     */
    async runInitialTests() {
        console.log('üß™ Running initial test suite...');

        const analysis = {
            runAll: true,
            reason: 'Initial run',
            affectedTests: [],
            estimatedTestTime: 0
        };

        await this.runTests(analysis);
    }

    /**
     * ËøêË°åÊµãËØï
     */
    async runTests(analysis) {
        const startTime = Date.now();
        this.runCount++;
        this.stats.totalRuns++;

        try {
            // Á°ÆÂÆöË¶ÅËøêË°åÁöÑÊµãËØïÊñá‰ª∂
            let testFilesToRun;
            if (analysis.runAll) {
                // ËøêË°åÊâÄÊúâÊµãËØïÊñá‰ª∂ - Ëé∑ÂèñÊâÄÊúâÊµãËØïÊñá‰ª∂
                const glob = require('glob');
                const testPatterns = ['test/**/*.test.js', '**/*.test.js'];
                testFilesToRun = [];

                for (const pattern of testPatterns) {
                    const files = glob.sync(pattern, {
                        cwd: process.cwd(),
                        absolute: false,
                        ignore: ['node_modules/**', 'coverage/**']
                    });
                    testFilesToRun = testFilesToRun.concat(files);
                }

                // ÂéªÈáç
                testFilesToRun = [...new Set(testFilesToRun)];
            } else {
                // ËøêË°åÁâπÂÆöÁöÑÊµãËØïÊñá‰ª∂
                testFilesToRun = analysis.affectedTests;
            }

            // ÊòæÁ§∫ËøêË°å‰ø°ÊÅØ
            this.showRunInfo(analysis, {
                files: testFilesToRun,
                parallel: this.options.enableParallel && testFilesToRun.length > 1
            });

            // ËøêË°åÊµãËØï
            const results = await this.testRunner.run(testFilesToRun);

            // ËÆ°ÁÆóËøêË°åÊó∂Èó¥
            const duration = Date.now() - startTime;
            this.stats.lastRunDuration = duration;

            // Êõ¥Êñ∞ÁªüËÆ°
            if (results.failed === 0) {
                this.stats.successfulRuns++;
            } else {
                this.stats.failedRuns++;
            }

            this.updateAverageRunTime(duration);

            // ÊòæÁ§∫ÁªìÊûú
            this.showResults(results, duration, analysis);

            // Êõ¥Êñ∞ÂèòÂåñÊ£ÄÊµãÂô®
            this.changeDetector.updateLastRunTimestamp();

            // ÂèëÈÄÅÈÄöÁü•ÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
            this.sendNotification(results, duration);

            this.emit('testComplete', { results, duration, analysis });

        } catch (error) {
            const duration = Date.now() - startTime;
            this.stats.failedRuns++;
            this.updateAverageRunTime(duration);

            console.error('‚ùå Test run failed:', error.message);

            this.emit('testError', { error, duration, analysis });
        }

        // ÊòæÁ§∫ÁõëÊéßÁä∂ÊÄÅ
        setTimeout(() => {
            this.showWatchStatus();
        }, 500);
    }

    /**
     * ÊòæÁ§∫Ê¨¢Ëøé‰ø°ÊÅØ
     */
    showWelcome() {
        console.log('üëÅÔ∏è ');
        console.log('üì¶ MiniTest Watch Mode');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        console.log('üí° Press Ctrl+C to exit');
        console.log('üîÑ Press r + Enter to run all tests');
        console.log('üßπ Press c + Enter to clear console');
        console.log('üìä Press s + Enter to show statistics');
        console.log('');
    }

    /**
     * ÊòæÁ§∫ÂèòÂåñ‰ø°ÊÅØ
     */
    showChangeInfo(changeInfo, analysis) {
        const timestamp = new Date().toLocaleTimeString();

        console.log(`[${timestamp}] üìù File changed: ${changeInfo.relativePath}`);

        if (analysis.reason) {
            console.log(`üìã Strategy: ${analysis.reason}`);
        }

        if (analysis.affectedTests.length > 0) {
            console.log(`üéØ Affected tests: ${analysis.affectedTests.length}`);

            if (this.options.verbose) {
                analysis.affectedTests.forEach(test => {
                    const relativePath = require('path').relative(process.cwd(), test);
                    console.log(`   ‚Üí ${relativePath}`);
                });
            }
        }

        console.log('');
    }

    /**
     * ÊòæÁ§∫ËøêË°å‰ø°ÊÅØ
     */
    showRunInfo(analysis, runOptions) {
        const fileCount = runOptions.files ? runOptions.files.length : 0;
        const runType = analysis.runAll ? `all tests (${fileCount} files)` : `${analysis.affectedTests.length} tests`;
        const parallel = runOptions.parallel ? ' (parallel)' : '';

        console.log(`üß™ Running ${runType}${parallel}...`);

        if (analysis.estimatedTestTime > 0) {
            console.log(`‚è±Ô∏è Estimated time: ${analysis.estimatedTestTime}ms`);
        }

        console.log('');
    }

    /**
     * ÊòæÁ§∫ÊµãËØïÁªìÊûú
     */
    showResults(results, duration, analysis) {
        const { passed, failed, total } = results;
        const emoji = failed === 0 ? '‚úÖ' : '‚ùå';
        const status = failed === 0 ? 'PASSED' : 'FAILED';

        console.log('');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        console.log(`${emoji} ${status}: ${passed}/${total} tests passed in ${duration}ms`);

        if (failed > 0) {
            console.log(`‚ùå Failed: ${failed}`);
        }

        // ÊòæÁ§∫ËøêË°åÁªüËÆ°
        console.log(`üìä Run #${this.runCount} (${this.stats.successfulRuns}‚úÖ ${this.stats.failedRuns}‚ùå)`);

        console.log('');
    }

    /**
     * ÊòæÁ§∫ÁõëÊéßÁä∂ÊÄÅ
     */
    showWatchStatus() {
        const watcherStats = this.fileWatcher.getStats();
        const detectorStats = this.changeDetector.getStats();

        console.log('üëÅÔ∏è Watching for changes...');
        console.log(`üìÅ Monitoring ${watcherStats.watchedFiles} files`);

        if (this.options.verbose) {
            console.log(`üß† Smart detection: ${detectorStats.smartDetection ? 'ON' : 'OFF'}`);
            console.log(`üíæ File hashing: ${detectorStats.hashingEnabled ? 'ON' : 'OFF'}`);
            console.log(`üìà Average run time: ${this.stats.averageRunTime}ms`);
        }

        console.log('');
    }

    /**
     * ÊòæÁ§∫ÊúÄÁªàÁªüËÆ°
     */
    showFinalStats() {
        console.log('');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Final Stats ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        console.log(`üî¢ Total runs: ${this.stats.totalRuns}`);
        console.log(`‚úÖ Successful: ${this.stats.successfulRuns}`);
        console.log(`‚ùå Failed: ${this.stats.failedRuns}`);
        console.log(`üìÅ Files changed: ${this.stats.filesChanged}`);
        console.log(`‚è±Ô∏è Average run time: ${this.stats.averageRunTime}ms`);
        console.log('');
        console.log('üëã Thanks for using MiniTest!');
    }

    /**
     * ÂèëÈÄÅÈÄöÁü•
     */
    sendNotification(results, duration) {
        if (!this.options.showNotifications) {
            return;
        }

        const shouldNotify = (results.failed === 0 && this.options.notifyOnSuccess) ||
            (results.failed > 0 && this.options.notifyOnFailure);

        if (shouldNotify) {
            // ËøôÈáåÂèØ‰ª•ÈõÜÊàêÊ°åÈù¢ÈÄöÁü•Á≥ªÁªü
            // ÁõÆÂâçÂè™Âú®ÊéßÂà∂Âè∞ÊòæÁ§∫
            const status = results.failed === 0 ? '‚úÖ Tests Passed' : '‚ùå Tests Failed';
            console.log(`üîî ${status} (${duration}ms)`);
        }
    }

    /**
     * Êõ¥Êñ∞Âπ≥ÂùáËøêË°åÊó∂Èó¥
     */
    updateAverageRunTime(duration) {
        if (this.stats.totalRuns === 1) {
            this.stats.averageRunTime = duration;
        } else {
            this.stats.averageRunTime = Math.round(
                (this.stats.averageRunTime * (this.stats.totalRuns - 1) + duration) / this.stats.totalRuns
            );
        }
    }

    /**
     * Ê∏ÖÂ±è
     */
    clearConsole() {
        // Windows Âíå Unix ÂÖºÂÆπÁöÑÊ∏ÖÂ±è
        process.stdout.write('\x1b[2J\x1b[0f');
    }

    /**
     * ÊâãÂä®Ëß¶ÂèëÊµãËØïËøêË°å
     */
    async runAllTests() {
        if (!this.isRunning) {
            console.log('‚ö†Ô∏è Watch mode is not running');
            return;
        }

        console.log('üîÑ Manually running all tests...');

        const analysis = {
            runAll: true,
            reason: 'Manual trigger',
            affectedTests: [],
            estimatedTestTime: 0
        };

        await this.runTests(analysis);
    }

    /**
     * Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ
     */
    getStats() {
        return {
            ...this.stats,
            isRunning: this.isRunning,
            runCount: this.runCount,
            watcher: this.fileWatcher.getStats(),
            detector: this.changeDetector.getStats()
        };
    }

    /**
     * Ê∏ÖÁêÜÁºìÂ≠ò
     */
    clearCache() {
        this.changeDetector.clearCache();
        console.log('üßπ Watch mode cache cleared');
    }
}

module.exports = WatchMode;
